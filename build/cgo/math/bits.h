/* Code generated by cmd/cgo; DO NOT EDIT. */

/* package command-line-arguments */


#line 1 "cgo-builtin-export-prolog"

#include <stddef.h> /* for ptrdiff_t below */

#ifndef GO_CGO_EXPORT_PROLOGUE_H
#define GO_CGO_EXPORT_PROLOGUE_H

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef struct { const char *p; ptrdiff_t n; } _GoString_;
#endif

#endif

/* Start of preamble from import "C" comments.  */


#line 3 "bits.go"

#include <stdlib.h>
#include <stdint.h>

typedef struct {
    unsigned int sum;
    unsigned int carry_out;
} bits_add_t;

typedef struct {
    uint32_t sum;
    uint32_t carry_out;
} bits_add32_t;

typedef struct {
    uint64_t sum;
    uint64_t carry_out;
} bits_add64_t;

typedef struct {
    unsigned int quo;
    unsigned int rem;
} bits_div_t;

typedef struct {
    uint32_t quo;
    uint32_t rem;
} bits_div32_t;

typedef struct {
    uint64_t quo;
    uint64_t rem;
} bits_div64_t;

typedef struct {
    unsigned int hi;
    unsigned int lo;
} bits_mul_t;

typedef struct {
    uint32_t hi;
    uint32_t lo;
} bits_mul32_t;

typedef struct {
    uint64_t hi;
    uint64_t lo;
} bits_mul64_t;

typedef struct {
    unsigned int diff;
    unsigned int borrow_out;
} bits_sub_t;

typedef struct {
    uint32_t diff;
    uint32_t borrow_out;
} bits_sub32_t;

typedef struct {
    uint64_t diff;
    uint64_t borrow_out;
} bits_sub64_t;

#line 1 "cgo-generated-wrapper"


/* End of preamble from import "C" comments.  */


/* Start of boilerplate cgo prologue.  */
#line 1 "cgo-gcc-export-header-prolog"

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];

#ifndef GO_CGO_GOSTRING_TYPEDEF
typedef _GoString_ GoString;
#endif
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif


/**
 * Add returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; 
 * otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1. 
 *
 * This function's execution time does not depend on the inputs.
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_add_t* add = bits_add(12, 32, 0);
 *  printf("Sum: %d\n", add->sum);
 *  printf("Carry out: %d", add->carry_out);
 *  free(add);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @param carry
 * @return bits_add_t
 */
extern bits_add_t* bits_add(unsigned int x, unsigned int y, unsigned int carry);

/**
 * Add32 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; 
 * otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_add32_t* add = bits_add32(12, 32, 0);
 *  printf("Sum: %d\n", add->sum);
 *  printf("Carry out: %d", add->carry_out);
 *  free(add);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @param carry
 * @return bits_add32_t
 */
extern bits_add32_t* bits_add32(uint32_t x, uint32_t y, uint32_t carry);

/**
 * Add64 returns the sum with carry of x, y and carry: sum = x + y + carry. The carry input must be 0 or 1; 
 * otherwise the behavior is undefined. The carryOut output is guaranteed to be 0 or 1.
 *
 * This function's execution time does not depend on the inputs.  
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_add64_t* add = bits_add64(12, 32, 0);
 *  printf("Sum: %d\n", add->sum);
 *  printf("Carry out: %d", add->carry_out);
 *  free(add);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @param carry
 * @return bits_add64_t
 */
extern bits_add64_t* bits_add64(uint64_t x, uint64_t y, uint64_t carry);

/**
 * Div returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y 
 * with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div panics for y == 0 
 * (division by zero) or y <= hi (quotient overflow).
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_div_t* div = bits_div(0, 6, 3);
 *  printf("%d\n", div->quo);
 *  printf("%d", div->rem);
 *  free(div);
 *  return 0;
 * }
 * * *
 *
 * @param hi
 * @param lo
 * @param y
 * @return bits_div_t
 */
extern bits_div_t* bits_div(unsigned int hi, unsigned int lo, unsigned int y);

/**
 * Div32 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y 
 * with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div32 panics for y == 0 
 * (division by zero) or y <= hi (quotient overflow). 
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_div32_t* div = bits_div32(0, 6, 3);
 *  printf("%d\n", div->quo);
 *  printf("%d", div->rem);
 *  free(div);
 *  return 0;
 * }
 * * *
 *
 * @param hi
 * @param lo
 * @param y
 * @return bits_div32_t
 */
extern bits_div32_t* bits_div32(uint32_t hi, uint32_t lo, uint32_t y);

/**
 * Div64 returns the quotient and remainder of (hi, lo) divided by y: quo = (hi, lo)/y, rem = (hi, lo)%y 
 * with the dividend bits' upper half in parameter hi and the lower half in parameter lo. Div64 panics for y == 0
 * (division by zero) or y <= hi (quotient overflow). 
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_div64_t* div = bits_div64(0, 6, 3);
 *  printf("%d\n", div->quo);
 *  printf("%d", div->rem);
 *  free(div);
 *  return 0;
 * }
 * * *
 *
 * @param hi
 * @param lo
 * @param y
 * @return bits_div64_t
 */
extern bits_div64_t* bits_div64(uint64_t hi, uint64_t lo, uint64_t y);

/**
 * LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_leading_zeros(1));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_leading_zeros(unsigned int x);

/**
 * LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_leading_zeros16(1));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_leading_zeros16(uint16_t x);

/**
 * LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_leading_zeros32(1));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_leading_zeros32(uint32_t x);

/**
 * LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_leading_zeros64(1));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_leading_zeros64(uint64_t x);

/**
 * LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_leading_zeros8(1));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_leading_zeros8(uint8_t x);

/**
 * Len returns the minimum number of bits required to represent x; the result is 0 for x == 0. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_len(8));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_len(unsigned int x);

/**
 * Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_len16(8));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_len16(uint16_t x);

/**
 * Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_len32(8));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_len32(uint32_t x);

/**
 * Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_len64(8));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_len64(uint64_t x);

/**
 * Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_len8(8));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_len8(uint8_t x);

/**
 * Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits'
 * upper half returned in hi and the lower half returned in lo.
 * 
 * This function's execution time does not depend on the inputs.
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_mul_t* mul = bits_mul(12, 12);
 *  printf("%d\n", mul->hi);
 *  printf("%d", mul->lo);
 *  free(mul);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @return bits_mul_t
 */
extern bits_mul_t* bits_mul(unsigned int x, unsigned int y);

/**
 * Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits'
 * upper half returned in hi and the lower half returned in lo. 
 * 
 * This function's execution time does not depend on the inputs.
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_mul32_t* mul = bits_mul32(12, 12);
 *  printf("%d\n", mul->hi);
 *  printf("%d", mul->lo);
 *  free(mul);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @return bits_mul32_t
 */
extern bits_mul32_t* bits_mul32(uint32_t x, uint32_t y);

/**
 * Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits'
 * upper half returned in hi and the lower half returned in lo.
 * 
 * This function's execution time does not depend on the inputs.
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_mul64_t* mul = bits_mul64(12, 12);
 *  printf("%d\n", mul->hi);
 *  printf("%d", mul->lo);
 *  free(mul);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @return bits_mul64_t
 */
extern bits_mul64_t* bits_mul64(uint64_t x, uint64_t y);

/**
 * OnesCount returns the number of one bits ("population count") in x.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_ones_count(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_ones_count(unsigned int x);

/**
 * OnesCount16 returns the number of one bits ("population count") in x.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_ones_count16(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_ones_count16(uint16_t x);

/**
 * OnesCount32 returns the number of one bits ("population count") in x. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_ones_count32(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_ones_count32(uint32_t x);

/**
 * OnesCount64 returns the number of one bits ("population count") in x.  
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_ones_count64(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_ones_count64(uint64_t x);

/**
 * OnesCount8 returns the number of one bits ("population count") in x.   
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_ones_count8(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_ones_count8(uint8_t x);

/**
 * Rem returns the remainder of (hi, lo) divided by y. Rem panics for y == 0 (division by zero) but
 * unlike Div, it doesn't panic on a quotient overflow.
 *
 * @param hi
 * @param lo
 * @param y
 * @return unsigned int
 */
extern unsigned int bits_rem(unsigned int hi, unsigned int lo, unsigned int y);

/**
 * Rem32 returns the remainder of (hi, lo) divided by y. Rem32 panics for y == 0 (division by zero) but,
 * unlike Div32, it doesn't panic on a quotient overflow.
 *
 * @param hi
 * @param lo
 * @param y
 * @return uint32_t
 */
extern uint32_t bits_rem32(uint32_t hi, uint32_t lo, uint32_t y);

/**
 * Rem64 returns the remainder of (hi, lo) divided by y. Rem64 panics for y == 0 (division by zero) but,
 * unlike Div64, it doesn't panic on a quotient overflow. 
 *
 * @param hi
 * @param lo
 * @param y
 * @return uint64_t
 */
extern uint64_t bits_rem64(uint64_t hi, uint64_t lo, uint64_t y);

/**
 * Reverse returns the value of x with its bits in reversed order.   
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse(19));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return unsigned int
 */
extern unsigned int bits_reverse(unsigned int x);

/**
 * Reverse16 returns the value of x with its bits in reversed order.    
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse16(19));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint16_t
 */
extern uint16_t bits_reverse16(uint16_t x);

/**
 * Reverse32 returns the value of x with its bits in reversed order.    
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse32(19));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint32_t
 */
extern uint32_t bits_reverse32(uint32_t x);

/**
 * Reverse64 returns the value of x with its bits in reversed order.    
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse64(19));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint64_t
 */
extern uint64_t bits_reverse64(uint64_t x);

/**
 * Reverse8 returns the value of x with its bits in reversed order.    
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse8(19));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint8_t
 */
extern uint8_t bits_reverse8(uint8_t x);

/**
 * ReverseBytes returns the value of x with its bytes in reversed order.    
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse_bytes(15));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return unsigned int
 */
extern unsigned int bits_reverse_bytes(unsigned int x);

/**
 * ReverseBytes16 returns the value of x with its bytes in reversed order.    
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse_bytes16(15));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint16_t
 */
extern uint16_t bits_reverse_bytes16(uint16_t x);

/**
 * ReverseBytes32 returns the value of x with its bytes in reversed order.    
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse_bytes32(15));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint32_t
 */
extern uint32_t bits_reverse_bytes32(uint32_t x);

/**
 * ReverseBytes64 returns the value of x with its bytes in reversed order.    
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_reverse_bytes64(15));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return uint64_t
 */
extern uint64_t bits_reverse_bytes64(uint64_t x);

/**
 * RotateLeft returns the value of x rotated left by (k mod UintSize) bits.
 * To rotate x right by k bits, call RotateLeft(x, -k).
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_rotate_left(15, 2));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param k
 * @return unsigned int
 */
extern unsigned int bits_rotate_left(unsigned int x, int k);

/**
 * RotateLeft16 returns the value of x rotated left by (k mod 16) bits.
 * To rotate x right by k bits, call RotateLeft16(x, -k).
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_rotate_left16(15, 2));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param k
 * @return uint16_t
 */
extern uint16_t bits_rotate_left16(uint16_t x, int k);

/**
 * RotateLeft32 returns the value of x rotated left by (k mod 32) bits.
 * To rotate x right by k bits, call RotateLeft32(x, -k).
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_rotate_left32(15, 2));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param k
 * @return uint32_t
 */
extern uint32_t bits_rotate_left32(uint32_t x, int k);

/**
 * RotateLeft64 returns the value of x rotated left by (k mod 64) bits.
 * To rotate x right by k bits, call RotateLeft64(x, -k).
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_rotate_left64(15, 2));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param k
 * @return uint64_t
 */
extern uint64_t bits_rotate_left64(uint64_t x, int k);

/**
 * RotateLeft8 returns the value of x rotated left by (k mod 8) bits.
 * To rotate x right by k bits, call RotateLeft8(x, -k).
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d\n", bits_rotate_left8(15, 2));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param k
 * @return uint8_t
 */
extern uint8_t bits_rotate_left8(uint8_t x, int k);

/**
 * Sub returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1;
 * otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_sub_t* sub = bits_sub(23, 12, 0);
 *  printf("%d\n", sub->diff);
 *  printf("%d", sub->borrow_out);
 *  free(sub);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @param borrow
 * @return bits_sub_t
 */
extern bits_sub_t* bits_sub(unsigned int x, unsigned int y, unsigned int borrow);

/**
 * Sub32 returns the difference of x, y and borrow, diff = x - y - borrow. The borrow input must be 0 or 1;
 * otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_sub32_t* sub = bits_sub32(23, 12, 0);
 *  printf("%d\n", sub->diff);
 *  printf("%d", sub->borrow_out);
 *  free(sub);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @param borrow
 * @return bits_sub32_t
 */
extern bits_sub32_t* bits_sub32(uint32_t x, uint32_t y, uint32_t borrow);

/**
 * Sub64 returns the difference of x, y and borrow: diff = x - y - borrow. The borrow input must be 0 or 1;
 * otherwise the behavior is undefined. The borrowOut output is guaranteed to be 0 or 1.
 *
 * This function's execution time does not depend on the inputs. 
 *
 * Example:
 * * *
 * int main()
 * {
 *  bits_sub64_t* sub = bits_sub64(23, 12, 0);
 *  printf("%d\n", sub->diff);
 *  printf("%d", sub->borrow_out);
 *  free(sub);
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @param y
 * @param borrow
 * @return bits_sub64_t
 */
extern bits_sub64_t* bits_sub64(uint64_t x, uint64_t y, uint64_t borrow);

/**
 * TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d", bits_trailing_zeros(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_trailing_zeros(unsigned int x);

/**
 * TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d", bits_trailing_zeros16(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_trailing_zeros16(uint16_t x);

/**
 * TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d", bits_trailing_zeros32(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_trailing_zeros32(uint32_t x);

/**
 * TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d", bits_trailing_zeros64(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_trailing_zeros64(uint64_t x);

/**
 * TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.
 *
 * Example:
 * * *
 * int main()
 * {
 *  printf("%d", bits_trailing_zeros8(14));
 *  return 0;
 * }
 * * *
 *
 * @param x
 * @return int
 */
extern int bits_trailing_zeros8(uint8_t x);

#ifdef __cplusplus
}
#endif
